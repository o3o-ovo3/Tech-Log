# 삽입 정렬 (Insertion Sort)

:writing_hand: *Assembled by Yunju Jang*

🤝*Contributors : JiYe Bae* 

<hr>



## 삽입 정렬 (Insertion Sort)

- <b>삽입 정렬이란?</b>

  - 손 안의 카드를 정렬하는 방법과 유사하다.
    - 새로운 카드를 기존의 정렬된 카드 사이의 올바른 자리에 삽입한다.
    - 새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬된다.
  - 자료 배열의 모든 요소를 <b>앞에서부터 차례로 이미 정렬된 배열 부분과 비교</b>하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.
  - 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.
  - 키 값을 두 번째 자료부터 시작하여, 그 앞의 자료들과 비교하여 알맞은 위치로 삽입하는 형태이다.

  <br/>

  <br/>

- <b>삽입 정렬 과정 (오름차순 정렬 기준)</b>

  - 두 번째 자료부터 시작하여 그 앞 (왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한다.
  - 지정한 위치의 원래 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.
  - 즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다.
    - 자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 뒤로 한 칸씩 이동시킨다.
  - 처음 Key 값은 두 번째 자료부터 시작한다.

  <img src='resources/insert.gif' width='500px' align='center'>

<br/>

<br/>

- <b>삽입 정렬 알고리즘 예제</b>

  - 배열에 [8, 5, 6, 2, 4] 가 저장되어 있다고 가정하고 오름차순으로 정렬한다.

    <img src='resources/InsertionSort.png' width='900px' align='center'>

    <br/>

    - <b>1회전 -</b> 두 번째 자료인 5를 Key 값으로 하여, 그 이전의 자료들과 비교한다.
      - Key 값 5와 첫 번째 자료인 8을 비교한다.
      - 8 > 5 이므로, 8 을 5자리에 넣고 Key 값 5를 8의 자리인 첫 번째 자리에 기억시킨다.
    - <b>2회전 -</b> 세 번째 자료인 6을 Key 값으로 하여, 그 이전의 자료들과 비교한다.
      - Key 값 6과 두 번째 자료 8을 비교한다.
        - 8 > 6 이므로, 8을 6이 있던 세 번째 자리에 기억시킨다. (뒤로 이동시킨다.)
      - Key 값 6과 첫 번째 자료인 5를 비교한다.
        - 5 < 6 이므로, 6을 두 번째 자리에 기억시킨다.
    - <b>3회전 -</b> 네 번째 자료인 2를 Key 값으로 하여, 그 이전의 자료들과 비교한다.
      - 2와 8을 비교한다.
        - 8 > 2 이므로, 8을 네 번째 자리에 기억시킨다. (뒤로 이동시킨다.)
      - 2와 6을 비교한다.
        - 6 > 2 이므로 6을 세 번째 자리에 기억시킨다. (뒤로 이동시킨다.)
      - 2와 5를 비교한다.
        - 5 > 2 이므로, 5를 두 번째 자리에 넣고 그 자리에 Key 값 2를 기억시킨다.
    - <b>4회전 -</b> 다섯 번째 자료인 4를 Key 값으로 하여, 그 이전의 자료들과 비교한다.
      - 4와 8을 비교한다.
        - 8 > 4 이므로, 8을 다섯 번째 자리에 기억시킨다.
      - 4와 6을 비교한다.
        - 6 > 4 이므로, 6을 네 번째 자리에 기억시킨다.
      - 4와 5를 비교한다.
        - 5 > 4 이므로, 5를 세 번째 자리에 기억시킨다.
      - 4와 2를 비교한다.
        - 4 > 2이므로, 4를 두 번째 자리에 기억시킨다.

<br/>

<br/>

- <b>삽입 정렬 예제 코드</b>

  ``` java
  public class InsertionSort {
      public static void main(String[] args) {
          int[] array = {8, 5, 6, 2, 4};
          int key;
          int i;
          int j;
  
          // insertion sort
          for (i = 1; i < array.length; i++) {
              // 인덱스 0은 정렬된 것으로 보고 1부터 시작한다.
              key = array[i]; // 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사
  
              // 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사한다.
              // j 값은 음수가 아니어야되고
              // key 값보다 정렬된 배열에 있는 값이 크면 j번쨰를 j+1번째로 이동한다.
              for (j = i - 1; j >= 0 && array[j] > key; j--) {
                  array[j + 1] = array[j]; // 레코드의 오른쪽으로 이동
              }
  
              array[j + 1] = key;
          }
  
          for (i = 0; i < array.length; i++) { // 정렬 결과 출력
              System.out.println(array[i]);
          }
      }
  }
  
  // 2, 4, 5, 6, 8
  ```

  <br/>

  <br/>

- <b>삽입 정렬의 특징</b>

  - 장점

    - 안정한 정렬 방법이다.
    - 레코드의 수가 적을 경우, 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리하다.
    - 대부분의 레코드가 이미 정렬되어 있는 경우 매우 효율적일 수 있다.

    <br/>

  - 단점

    - 비교적 많은 레코드들의 이동을 포함한다.
    - 레코드 수가 많고 레코드의 크기가 클 경우 적합하지 않다.

<br/>

<br/>

- <b>삽입 정렬 시간 복잡도</b>

  - 최선의 경우

    - 비교 횟수
      - 이동 없이 1번의 비교만 이루어진다.
      - 외부 루프 : (n-1)번
    - 시간 복잡도 : O(n)

    <br/>

  - 최악의 경우

    - 자료가 역순으로 입력되어 있는 경우
    - 비교 횟수
      - 외부 루프 안의 각 반복마다 i번의 비교 수행
      - 외부 루프 : (n-1) + (n-2) + ... + 2 + 1 = n(n-1)/2 = O(n^2)
    - 교환 횟수
      - 외부 루프의 각 단계마다 (i+2)번의 이동 발생
      - n(n-1)/2 + 2(n-1) = n(^2+3n-4)/2 = O(n^2)
    - 시간 복잡도 : O(n^2)


<br/>

<br/>

## 예상질문❔

Q1) 삽입 정렬이란 무엇인가?

A1) 키(key) 값을 두 번째 자료부터 지정하여, 그 앞의 자료들과 비교하여 알맞은 위치로 삽입하는 형태의 정렬이다.

<br/>

<br/>

### Reference📖

- https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html
- https://prosto.tistory.com/163

